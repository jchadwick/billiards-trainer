name: Build and Deploy Docker Containers

on:
  push:
    branches:
      - main
      - develop
    tags:
      - 'v*'
  pull_request:
    branches:
      - main
      - develop
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      force_rebuild:
        description: 'Force rebuild even if no changes'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Build and test the Docker images
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    outputs:
      backend-digest: ${{ steps.build-backend.outputs.digest }}
      backend-tag: ${{ steps.meta-backend.outputs.tags }}
      frontend-digest: ${{ steps.build-frontend.outputs.digest }}
      frontend-tag: ${{ steps.meta-frontend.outputs.tags }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Backend build
      - name: Extract metadata (backend)
        id: meta-backend
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/backend
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=semver,pattern={{major}}
            type=raw,value=latest,enable={{is_default_branch}}
            type=sha,prefix=sha-,format=short

      - name: Build and push backend image
        id: build-backend
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile
          target: production
          push: true
          tags: ${{ steps.meta-backend.outputs.tags }}
          labels: ${{ steps.meta-backend.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            BUILD_DATE=${{ github.event.head_commit.timestamp }}
            BUILD_VERSION=${{ steps.meta-backend.outputs.version }}
            BUILD_COMMIT=${{ github.sha }}

      # Frontend build
      - name: Extract metadata (frontend)
        id: meta-frontend
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/frontend
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=semver,pattern={{major}}
            type=raw,value=latest,enable={{is_default_branch}}
            type=sha,prefix=sha-,format=short

      - name: Build and push frontend image
        id: build-frontend
        uses: docker/build-push-action@v5
        with:
          context: ./frontend/web
          file: ./frontend/web/Dockerfile
          target: production
          push: true
          tags: ${{ steps.meta-frontend.outputs.tags }}
          labels: ${{ steps.meta-frontend.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # # Test the complete system with docker-compose
  # integration-test:
  #   runs-on: ubuntu-latest
  #   needs: build

  #   steps:
  #     - name: Checkout repository
  #       uses: actions/checkout@v4

  #     - name: Log in to Container Registry
  #       uses: docker/login-action@v3
  #       with:
  #         registry: ${{ env.REGISTRY }}
  #         username: ${{ github.actor }}
  #         password: ${{ secrets.GITHUB_TOKEN }}

  #     - name: Create test environment file
  #       run: |
  #         cat > .env.test << EOF
  #         # Test environment configuration
  #         ENVIRONMENT=test
  #         DEBUG=false
  #         LOG_LEVEL=INFO

  #         # Security (test values)
  #         JWT_SECRET_KEY=test-secret-key-for-ci-only
  #         JWT_ALGORITHM=HS256
  #         JWT_ACCESS_TOKEN_EXPIRE_MINUTES=30
  #         DEFAULT_API_KEY=test-api-key

  #         # API configuration
  #         API_PORT=8000
  #         METRICS_PORT=9090

  #         # Redis configuration
  #         REDIS_PORT=6379
  #         REDIS_MAX_MEMORY=128mb

  #         # Resource limits for CI
  #         BACKEND_MEMORY_LIMIT=2G
  #         BACKEND_CPU_LIMIT=1.0
  #         BACKEND_MEMORY_RESERVATION=512M
  #         BACKEND_CPU_RESERVATION=0.25

  #         # Use built image
  #         BUILD_VERSION=${{ needs.build.outputs.image-tag }}
  #         EOF

  #     - name: Start services with docker-compose
  #       run: |
  #         docker-compose --env-file .env.test up -d backend redis

  #         # Wait for services to be healthy
  #         timeout=60
  #         while [ $timeout -gt 0 ]; do
  #           if docker-compose --env-file .env.test ps | grep -E "(healthy|Up)"; then
  #             echo "Services are running"
  #             break
  #           fi
  #           sleep 2
  #           timeout=$((timeout-2))
  #         done

  #     - name: Test API endpoints
  #       run: |
  #         # Wait for API to be ready
  #         timeout=30
  #         while [ $timeout -gt 0 ]; do
  #           if curl -f http://localhost:8000/api/v1/health; then
  #             echo "API is healthy"
  #             break
  #           fi
  #           sleep 1
  #           timeout=$((timeout-1))
  #         done

  #         # Test basic endpoints
  #         curl -f http://localhost:8000/api/v1/health || exit 1
  #         echo "Health check passed"

  #     - name: Check service logs
  #       if: failure()
  #       run: |
  #         echo "=== Backend Logs ==="
  #         docker-compose --env-file .env.test logs backend
  #         echo "=== Redis Logs ==="
  #         docker-compose --env-file .env.test logs redis

  #     - name: Cleanup
  #       if: always()
  #       run: |
  #         docker-compose --env-file .env.test down -v
  #         docker system prune -f

  # Deploy to staging/production
  # deploy:
  #   runs-on: ubuntu-latest
  #   needs: [build, integration-test]
  #   if: github.event_name == 'workflow_dispatch' || (github.event_name == 'push' && github.ref == 'refs/heads/main')

  #   environment: ${{ github.event.inputs.environment || 'staging' }}

  #   steps:
  #     - name: Checkout repository
  #       uses: actions/checkout@v4

  #     - name: Deploy to ${{ github.event.inputs.environment || 'staging' }}
  #       run: |
  #         echo "ðŸš€ Deploying to ${{ github.event.inputs.environment || 'staging' }}"
  #         echo "Image: ${{ needs.build.outputs.image-tag }}"
  #         echo "Digest: ${{ needs.build.outputs.image-digest }}"

  #         # This is where you would add your deployment commands
  #         # Examples:
  #         # - SSH to server and pull new images
  #         # - Use kubectl to deploy to Kubernetes
  #         # - Use Docker Swarm commands
  #         # - Update AWS ECS service
  #         # - Deploy to cloud provider

  #         echo "Deployment completed successfully!"

  #     - name: Create deployment summary
  #       run: |
  #         cat >> $GITHUB_STEP_SUMMARY << EOF
  #         # Deployment Summary

  #         **Environment:** ${{ github.event.inputs.environment || 'staging' }}
  #         **Image:** ${{ needs.build.outputs.image-tag }}
  #         **Commit:** ${{ github.sha }}
  #         **Actor:** ${{ github.actor }}

  #         ## Services Deployed
  #         - âœ… Backend API
  #         - âœ… Redis Cache
  #         - âœ… Monitoring (if enabled)

  #         ## Next Steps
  #         - Verify deployment health
  #         - Run smoke tests
  #         - Monitor application metrics
  #         EOF

  # Cleanup old images
  # cleanup:
  #   runs-on: ubuntu-latest
  #   needs: [build]
  #   if: always() && (github.event_name == 'push' && github.ref == 'refs/heads/main')

  #   permissions:
  #     contents: read
  #     packages: write

  #   steps:
  #     - name: Delete old container images
  #       uses: actions/delete-package-versions@v4
  #       with:
  #         package-name: ${{ env.IMAGE_NAME }}/backend
  #         package-type: container
  #         min-versions-to-keep: 10
  #         delete-only-untagged-versions: true
